# Paper Reading Record
## Content
- 

------
## （SIGGRAPH2023）3D Gaussian Splatting for Real-Time Radiance Field Rendering 
 
keywords：GS；场景表示；可微渲染  

通过一系列三维高斯参数的优化步骤，即位置、协方差、𝛼和SH系数与高斯密度的自适应控制操作交织，**创建辐射场表示**  

3D高斯保留了连续体积辐射场的理想特性以进行场景优化，同时避免了在空白空间中不必要的计算   
3D高斯的交替优化/密度控制（优化各向异性协方差）  

对各向异性协方差的优化、交叉优化/密度控制、以及高效的渲染深度排序，使之能够处理完整的、复杂的场景，包括背景，包括室内和室外，并具有较大的深度复杂性  

### Background：
NeRF建立在连续场景表示的基础上，通常使用体积射线优化MLP；通过对存储在如体素或哈希网格或点上的值进行插值； &emsp; 这些方法的连续性有助于优化，但渲染所需的随机采样代价高昂，并可能导致噪声  
NeRF优化的三个常见策略：空间数据结构存特征，通过体射线插值；不同的编码测量；不同的MLP容量   
但依然无法有效表示场景中空的部分  

### 问题：
1、如何进行场景表示？  
2、如何进行基于点的渲染？  
2、如何优化场景表示？（对于 缺乏几何的under-reconstruction区域 & 高斯覆盖太多的over-reconstruction区域）（可微渲染与梯度回传、自适应密度控制策略）  

### 3D Gaussian
属性：三维位置，不透明度𝛼，各向异性协方差，球谐（SH）系数   
以一个点为mean，在世界坐标系中定义的三维协方差矩阵Σ  
<b>继承了可微体积表示的属性，同时是非结构化的、显式的</b>   

点是一种非结构化的、离散的表示，它足够灵活，通过优化不透明度和位置，允许创建、破坏和类似NeRF的几何置换   
高度各向异性的体积splats可以紧凑地表示精细的几何结构  
辐射场的方向性外观分量（颜色）通过球谐函数（SH）表示   

协方差矩阵要求是半正定的，直接梯度回传不能保证保持这一性质   
<b>使用缩放矩阵与旋转矩阵构成相应的协方差矩阵</b>（三维高斯分布的协方差矩阵类似于椭球体的表示），用一个三维向量`s`和一个四元数`q`来表示旋转    
显式地推导了所有参数的梯度  

### 基于点的渲染（splat）
在基于点的高质量渲染方面，开创性工作通过“splat”范围大于像素的点图元来解决这些问题   
基于点的α混合方法和NeRF体渲染中的图像生成模型本质上相同  

文中的设计目标：不应需要初始的MVS几何图形，并在已排序的splats上保持（近似的）传统的𝛼混合，以具有体积表示的优势  
关键：<b>对于一张图像根据可见性对图元进行排序、并在一个像素的所有splats上反向传播梯度</b>  

将屏幕划分为16*16的tiles（每个tile对应后续一个渲染thread block），根据视锥和每个tile对高斯们进行裁切，只保留与视锥相交具有99%置信度的高斯  
根据覆盖tiles的数量实例化每个高斯核，为每个实例分配一个组合了视图空间
深度和tileID的key（后续根据这个key排序，α-混合根据这个排序进行）  
渲染时，每个thread block首先协作地将高斯数据包加载到共享内存中，然后，对于给定的像素，通过从前到后遍历列表来累积颜色和 α 值，在一个像素中的 α 值达到目标饱和时，相应的线程停止；定期查询一个tile中的线程，当所有像素都已经饱和时（α 到1）时，整个tile的渲染终止   

反向传递过程中，倒序遍历每个tile的列表   
只有在深度低于或等于forward过程中最后一个产生颜色贡献的点时，才进行overlap test
每个点在forward过程中存储最终累积的不透明度 ，将其除以前后遍历中每个点自身的α ，以得到梯度计算所需的系数 

### 自适应密度控制
3D高斯的协方差矩阵参数的质量对于表示的致密性至关重要，因为少量的大的各向异性高斯即可捕获大的齐次区域   
使用随机梯度下降进行优化   

缺乏几何的under-reconstruction区域 和 高斯覆盖太多的over-reconstruction区域 都是需要densify的区域；且它们具有共同特点：较大的视图差异梯度  
under-reconstruction：朝着梯度方向复制一个高斯核  
over-reconstruction（高方差区域中的大高斯分布）：使用原始的3D高斯分布作为PDF进行采样后，分裂成两个小高斯核  

周期性地去除在世界坐标系中非常大的高斯和在视图坐标系中有很大footprint的高斯，以控制高斯总数    

### 训练细节
使用随机梯度下降进行优化  
使用 *sigmod激活函数* 将 α 约束在`[0−1)`范围内，并获得平滑的梯度  
对协方差尺度使用 *指数激活函数*   

初始化协方差矩阵为一个各向同性高斯矩阵，其轴等于到最近的三个点的距离的平均值  

每100次迭代进行一次densify，并删除接近透明（α 小于阈值）的高斯分布

<br>

------
## GaussianEditor: Swift and Controllable 3D Editing with Gaussian Splatting

arxiv202311  
keywords：3D编辑；GS；  

通过自然语言编辑GS场景；利用GS的显式表示的典型特性来提升3D编辑的效果；  
采用2D diffusion model进行编辑    
对于大场景的编辑，在编辑过程中使用的相机姿态是从最初用于重建的多视图图像数据集的一个子集中选择的；对于指定目标对象的编辑，生成了一组紧密围绕着分割物体的相机位姿；此外，当目标对象与场景的关联程度较低时，选择只渲染目标对象    

### Background：  
基于高维MLP的方法对场景进行了隐式编码，很难进行inpaint和decompose  
（某种观点认为）与隐式表示的方法有神经网络作为缓冲不同，GS在训练时直接受到损失的随机性影响，gaussian的属性在训练中直接改变，导致训练不稳定  

3D编辑的两种思路：
- 将3D模型的噪声渲染作为输入；由扩散模型生成的分数来指导模型更新
- 根据prompt对3D模型的多个视图进行2D编辑

### 问题：  
1、如何识别需要编辑的gaussian？（作者提出了 **gaussian semantic trace**）  
&emsp; 同时，gaussian semantic trace 可以视为一种动态的mask  
2、如何解决编辑时随机性（具有高度随机性的生成引导）带来的问题？（作者提出了 **HGS**）  
3、如何解决物体删除带来的边缘空洞or填入物体？ （作者提出了一种 **3D inpainting** 的方法）   
&emsp; image to 3Dmesh，再转为GS  

### Gassian semantic tracing
*确保只有目标相关区域被修改，使得编辑精准、可控*  
将二维分割mask投影到三维高斯，并为每个高斯分配一个语义属性（j类语义标签）  
编辑时只更新目标高斯  
致密化过程中，新致密的高斯继承其父高斯的语义属性  
对于一组3D高斯，生成多个渲染图并运用2D分割，再将2D分割语义标签投影回GS模型   
为每个高斯维护一个权重和一个计数器   
`wij`表示第i个高斯对第j个标签的权重；根据一个高斯分布的平均权重是否超过一个手动设置的阈值来确定它是否属于第j个语义类    

### Hierarchical Gaussian splatting (HGS)
*对于生成式任务，使能够连续优化出更好的结果，从而模拟了通过神经网络隐式表示实现的缓冲函数*   
基于在编辑任务的训练过程的多个致密化过程中的序列，将GS组织成代  
早期致密化中形成的高斯具有更严格的约束（保持原始状态）  
引入Anchor Loss；在各属性的锚点状态和当前状态之间分别计算MSE损失，确保高斯不会偏离各自的锚点状态太远   
通过调整不同属性、不同代AnchorLoss的权值实现控制编辑   
对于致密化过程，有选择地只密度化那些三维位置梯度在 top k% 内的高斯  

### 3D inpainting algorithm
*对于去除对象后的局部修复算法，以及提供prompt和2Dmask的对象添加算法*   
删除物体后，使用KNN识别最接近被移除物体的高斯（很可能是在交接处），再投影到多个视角下（形成2D mask），调用2D inpainting算法   
对于要添加的物体，先使用2D inpainting（用户提供2D mask输入），再使用image to 3D转换成粗糙网格，再转成HGS并精细化（使用AnchorLoss）   
对于新加物体高斯与原场景高斯的坐标系对齐，首先估计新生成的图像的深度 

---