# Go Language
---
## 语言特性

---
## 基本语法
---

### 并发&协程
并发：多个线程在单核上运行（时间切片）  
并行：多个线程直接在多核上运行  
Go语言能够充分发挥多核优势，更适合高并发场景  

协程：用户态    
线程：内核态（更消耗系统资源） 可以并发地运行多个协程  

在函数调用前添加 `go` 关键字，创建协程运行  

协程间提倡 <b>通过通信共享内存</b> （通道）  
`make(chan 类型, [大小])`  
带缓冲的channel可以解决生成和消费速度不平衡的问题  

共享内存 存在多个goroutine同时操作一块内存的情况  
`sync.Mutex`  

`sync.WaitGroup` 协程间同步  
```go
func ManyGoWait() {
	var wg sync.WaitGroup
	wg.Add(5) // 计数器增加delta  Add(delta int)
	for i := 0; i < 5; i++ {
		go func(j int) {
			defer wg.Done() // 计数器减1
			hello(j)
		}(i)
	}
	wg.Wait() // 阻塞至计数器为0
}
```

<br>

---
### 依赖管理
<b>GOPATH</b>： go语言的环境变量（工作区）  
bin： 项目编译的二进制文件  
pkg： 项目编译的中间产物，加速编译  
src： 项目编译的源码（项目代码直接依赖于src下的源码）  
问题：无法实现package的多版本控制  

<b>Go Vendor</b>： 项目目录下增加vendor文件，所有依赖包以副本存放在 $ProjectRoot/vendor 下  
问题：无法控制依赖的版本（直接依赖源码 不能标识版本）  

<b>Go Module</b>：通过 go.mod 文件管理依赖包版本 &emsp; 通过 `go get/go mod` 指令工具管理依赖包  

Proxy 保证了依赖的稳定性（相对于直接从第三方代码平台）

<br>

---
### 错误和异常处理
优先使用 `errors.New` 来创建匿名变量来直接表示该错误。有格式化需求时使用 `fmt.Errorf`  
在 `fmt.Errorf` 中使用 `%w` 关键字来将一个错误 wrap 至其错误链中

使用 `errors.Is` 可以判定错误链上的所有错误是否含有特定的错误  
使用 `errors.As` 在错误链上获取特定种类的错误

`error` 尽可能提供简明的上下文信息链，方便定位问题  
`panic` 一般不在业务逻辑中使用（如果当前 goroutine 中所有 deferred 函数都不包含 recover 就会造成整个程序崩溃）。用于真正异常（不能继续下去）的情况：当程序启动阶段发生不可逆转的错误时，可以在 init 或 main 函数中使用 panic   
`recover` 生效范围：在当前goroutine的被defer的函数中  

<br>

---
### 性能优化建议
<b>预分配内存</b> 尽可能在 `make()` 创建切片（slice）、map 时提供初始容量信息   

切片的本质是一个数组片段的描述，包括：数组指针、片段的长度、片段的容量（不改变内存分配情况下的最大容量）  
切片操作并不复制切片指向的元素   
在已有切片基础上创建一个新的切片（ `origin[len(origin)-2:]` ）会复用原切片的底层数组  
建议：`make` 一个新切片，再调用 `copy` 拷贝原切片的部分  

使用 `strings.Builder` 或 `bytes.Buffer` 处理拼接字符串（两者也都可以预分配内存）  
`bytes.Buffer` 转化为字符串重新申请了一块空间， `strings.Builder` 直接将底层的 []byte 转换为字符串类型返回   

空结构体实例不占用内存空间，可作占位符  
`m := make(map[int]struct{})` 实现 Set  

通过 atomic 包 维护原子变量  
上锁是操作系统实现的，属于系统调用，`sync.Mutex` 一般用于保护一段逻辑  
atomic 操作是通过硬件实现的   
对于非数值系列，可以使用 `atomic.Value`，`atomic.Value` 能承载一个 `interface{}`  

<br>

---
### 自动内存管理（GC）
Mutator：业务线程，分配新对象，修改对象指向关系  
Collector：GC线程，找到存活对象，回收死亡对象的内存空间  

GC算法：
* Serial GC：只有一个 Collector  
* Parallel GC：支持多个 Colletors同时回收   
* Concurrent GC：Collector(s) 和 Mutator(s)可以同时执行  
  Collector(s) 必须感知到对象指向关系的改变 （已标记为存货的对象所指向的对象必须要标记） 

<br>

### 追踪垃圾回收 Tracing Garbage Collection
<b>对象被回收的条件：指针指向关系不可达的对象</b>  
标记根对象：静态变量、全局变量、常量、线程栈等  
标记：找到所有可达对象（<b>求指针指向关系的传递闭包</b>）  
清理所有不可达对象：清理策略  
&emsp; Copying GC：将存活对象复制到另外的内存空间  
&emsp; Mark-sweep GC：将死亡对象的内存标记为“可分配”（使用freelist管理空闲内存）  
&emsp; Mark-compact GC：移动并整理存活对象  
<b>根据对象的生命周期，使用不同的标记和清理策略</b>  

* ### 分代GC &emsp; Generational GC
基于分代假说（Generational hypothesis）：most objects die young.  
每个对象都有“年龄”：经历过 GC 的次数  
目的：对年老和年轻的对象制定不同的GC策略，降低整体内存管理的开销  
不同年龄的对象处在heap的不同区域  

年轻代：由于存活的对象少，可以使用 Copying GC；GC 吞吐率高  
年老代：趋于一直活着，反复复制开销大，可以使用 Mark-sweep GC  

<br>

### 引用计数 Reference Counting
<b>每个对象都有一个与之关联的引用数目</b>  
对象存活：当且仅当引用数大于0  

优点：内存管理的操作被平摊到程序运行中 & 不需要了解 runtime 的实现细节  
缺点：
- 维护开销大，通过<b>原子操作</b>保证对引用计数操作的原子性和可见性  
- 无法回收环形引用  
- 内存开销：每个对象都引入额外内存空间  
- 回收（大数据结构）内存时依然可能引发暂停  

<br>

---
### Go内存分配
Go 内存分配 ———— <b>提前将内存分块</b>  
noscan mspan：分配不包含指针的对象 ———— GC不需要扫描  
scan mspan：分配包含指针的对象 ———— GC需要扫描  

Go 内存分配 ———— <b>对内存做多级缓存</b>  
借鉴 TCMalloc（Thread Caching）  
mcache 管理一组 mspan  
当 mspan 中没有分配对象（mspan为空）时，不会直接释放归还给 OS，而是会被缓存到 mcentral 中供其他 mcache 使用  

优化方案：Balanced GC  
每个 g 绑定一大块内存（1KB），称作 Goroutine allocation buffer（GAB）  
GAB 用于 nospan 的小对象（< 128B）分配  
使用三个指针 start，end，top 维护GAB   
使用 Bump Pointer（指针碰撞）风格作对象分配，只需移动指针，且不需与其他 g 互斥  
GAB 对 go内存管理来说是一个大对象（<b>把多个小对象的分配合并成一个大对象的分配</b>）  
问题：只有一个小对象时，也导致 GAB 占用的内存延迟释放  
方案：移动存活的对象（<b>用 Copying GC 管理小对象</b>）；当 g 的 GAB 总大小超过一定阈值时，将 GAB 中存活的对象复制到另外分配的 GAB 中，原先的 GAB 可以释放  

<br>

---
### 编译器和静态分析（编译优化）
静态分析：不执行代码，推导程序的行为，分析程序的性质  
控制流：程序执行的流程（代码块组成控制流图）  
数据流：数据在控制流上的传递  

过程内分析：仅在函数内部进行分析  
过程间分析：考虑过程调用时参数传递和返回值的数据流和控制流  

### Go 编译器优化  
函数内联（Inlining）：消除函数调用开销；把过程间分析转化为过程内分析  

逃逸分析：分析代码中指针的动态作用域（指针在何处被访问）  
- 从对象分配处出发，沿着控制流，观察对象的数据流  
- 是否 作为参数传递给其他函数；传递给全局变量；传递给其他goroutine；传递给已逃逸的指针所指的对象  

未逃逸的对象可以在栈上分配，分配与回收的速度更快，并减少了在 heap 上的分配，降低了 GC 负担  

---
### GORM 数据库操作
* GORM 查询数据  

Go 语言中实现对象和数据库映射的框架

使用 First 获取第一天（主键升序）时，注意查询不到数据时会返回 ErrRecordNotFound  
使用 Find 查询多条数据，查询不到数据时不会返回错误  
使用 struct 作为条件时，只会构造非零值作为条件；可使用 Map 构造含0的条件或使用 Select  
 
* GORM 更新数据  
  
使用 struct 更新时，只会更新非零值；可使用 Map 更新或使用 Select 选择字段  

### Kitex RPC操作
<b>使用IDL定义服务与接口</b>  
抽象出基础服务，可以复用  

如果我们要进行 RPC ，就需要知道对方的接口是什么，需要知道传什么样的参数与返回值的类型。通过 IDL 来约定双方的协议  

### Hertz HTTP框架
<b>对外提供 API，实现接口聚合</b>

<br>

---
## 规则引擎
规则引擎是一种嵌入在应用程序中的组件。实现了 <b>将业务决策从应用程序代码中分离出来</b>，并使用预定义的语义模块编写业务决策。接受数据输入，解释业务规则，并根据业务规则做出业务决策   

输入：计算规则、商品价格、用户标签、商品属性...  
输出：获得的积分  
规则简单容易配置、可扩展  

<b>数据输入：</b>
- 支持接受使用预定义的语义编写的规则作为策略集
- 接受业务的数据（如价格、标签）作为执行过程中的参数  

<b>规则理解：</b>
- 能够按照预先定义的词法、语法、优先级、运算符等正确理解业务规则所表达的语义

<b>规则执行：</b>
- 根据执行时输入的参数对策略集的规则进行正确的解释和执行
- 对执行过程中的数据类型进行检查，确保执行结果正确

---
### 规则引擎的实现（编译原理）
理解：词法分析、语法分析  
执行：抽象语法树（唯一地表示一个表达式）  
输入输出：参数注入、类型检查（遍历树）  

词法分析 将源代码字符串转换成词法单元（切分表达式）  
通过 <b>有限自动机</b> 识别token   

语法分析 在词法分析基础上识别表达式（token流）的语法结构   
转换成抽象语法树，每一个节点（子树）代表一个语法单元   
BNF范式在语法定义时就蕴含了一定的优先级信息  
递归下降算法：自顶向下构建语法树，不断对token进行语法展开  
对优先级的表达：
```go
type precedence struct {
	validSymbols []Symbol; // 当前优先级支持的运算符类型
	nextPrecedence *precedence; // 更高优先级的
	planner planner; // 当前优先级的处理函数
}
```

语法树执行  
预先定义好每种操作符（语法树节点）的执行逻辑 后序遍历二叉树

类型检查  
类型综合：根据子表达式的类型构造父表达式的类型   
类型检查可以发生在表达式的编译阶段（构造语法树阶段），需要提前声明参数的类型；也可以发生在执行的阶段   
在一个节点的左右节点执行完成后，分别校验左右子节点的类型是否符合 <b>对应操作符的类型检查预设规则</b>  


